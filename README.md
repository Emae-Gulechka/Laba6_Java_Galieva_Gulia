# Галиева Гулия ИТ-6 Лабораторная №6 

# Задание 1
## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
1. Создание аннотации @Invoke
Использовать @Target(ElementType.METHOD) для указания, что аннотация применяется только к методам
Использовать @Retention(RetentionPolicy.RUNTIME) для доступности во время выполнения
Создать пустой интерфейс аннотации без свойств
2. Создание демонстрационного класса
Создать класс с несколькими методами
Пометить минимум один метод аннотацией @Invoke
3. Реализация обработчика через Reflection API
Создать статический метод для обработки аннотированных методов
Использовать Class.getDeclaredMethods() для получения всех методов класса
Использовать Method.isAnnotationPresent(Invoke.class) для проверки наличия аннотации
Использовать Method.invoke() для вызова найденных методов
Обработать исключения при вызове методов

# Задание 1
## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию
### Алгоритм решения
1. Создание аннотации @Default
Использовать @Target({ElementType.TYPE, ElementType.FIELD}) для применения к типам и полям
Использовать @Retention(RetentionPolicy.RUNTIME) для доступности во время выполнения
Добавить обязательное свойство value() типа Class<?>
2. Создание демонстрационного класса
Пометить класс аннотацией @Default с указанием типа по умолчанию
Добавить несколько полей, некоторые из которых аннотировать @Default
Оставить некоторые поля без аннотации для сравнения
3. Реализация обработчика
Создать метод для анализа аннотации на классе
Использовать Class.isAnnotationPresent(Default.class) для проверки наличия аннотации
Использовать Class.getAnnotation(Default.class) для получения значения аннотации
Вывести имя класса, указанного в свойстве value


# Задание 1
## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.
### Алгоритм решения
1. Создание перечисления Mode
Создать enum Mode с значениями YES и NO
Использовать для указания режима отображения
2. Создание аннотации @ToString
Использовать @Target({ElementType.TYPE, ElementType.FIELD})
Использовать @Retention(RetentionPolicy.RUNTIME)
Добавить свойство value() типа Mode со значением по умолчанию Mode.YES
3. Создание демонстрационного класса
Пометить класс аннотацией @ToString(Mode.YES)
Добавить поля с разными аннотациями:
@ToString(Mode.YES) - для отображения
@ToString(Mode.NO) - для скрытия
Без аннотации (по умолчанию YES)
4. Реализация метода toStringWithAnnotations()
Использовать Reflection API для получения всех полей класса
Проверить аннотацию на классе: если @ToString(Mode.NO) - вернуть общее представление
Для каждого поля:
Проверить наличие аннотации @ToString на поле
Если аннотация @ToString(Mode.YES) или поле без аннотации - добавить в строку
Если аннотация @ToString(Mode.NO) - пропустить поле
Сформировать строковое представление только с разрешенными полями
5. Создание обработчика ToStringHandler
Реализовать статический метод для генерации строкового представления
Добавить дополнительную логику (маскирование паролей и т.д.)

# Задание 1
## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
1. Создание аннотации @Validate
Использовать @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})
Использовать @Retention(RetentionPolicy.RUNTIME)
Добавить обязательное свойство value() типа Class<?>[] (массив классов)
2. Создание демонстрационного класса
Пометить класс аннотацией @Validate с массивом классов для проверки
Указать различные типы классов (String, Integer, Double и т.д.)
3. Реализация обработчика
Создать метод для чтения аннотации @Validate
Использовать Class.getAnnotation(Validate.class).value() для получения массива классов
Вывести информацию о каждом классе в массиве
Реализовать проверку соответствия полей класса указанным типам

# Задание 1
## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
1. Создание аннотации @Two
Использовать @Target(ElementType.TYPE) только для типов
Использовать @Retention(RetentionPolicy.RUNTIME)
Добавить два обязательных свойства:
first() типа String
second() типа int
2. Создание демонстрационного класса
Пометить класс аннотацией @Two с конкретными значениями свойств
Добавить поля, соответствующие типам свойств аннотации
Реализовать методы для работы с этими полями
3. Реализация обработчика
Создать метод для чтения значений из аннотации @Two
Использовать Class.getAnnotation(Two.class) для получения аннотации
Вывести значения свойств first() и second()
Реализовать загрузку значений из аннотации в объект

# Задание 1
## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.
### Алгоритм решения
1. Создание аннотации @Cache
Использовать @Target(ElementType.TYPE) только для типов
Использовать @Retention(RetentionPolicy.RUNTIME)
Добавить необязательное свойство value() типа String[]
Установить значение по умолчанию: пустой массив {}
2. Создание демонстрационного класса с кэшем
Пометить класс аннотацией @Cache с массивом строк (имена областей кэша)
Создать структуру данных для хранения кэша (например, Map<String, Map<String, Object>>)
Реализовать методы для работы с кэшем (put, get)
3. Реализация обработчика
Создать метод для анализа аннотации @Cache
Проверить наличие аннотации на классе
Получить массив строк из свойства value()
Если массив пуст - вывести сообщение, что кэширование не активировано
Если массив не пуст - вывести список областей кэширования
